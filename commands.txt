Step 1: Configure Raspberry Pi as Access Point
Install Required Packages:

bash
sudo apt update
sudo apt install hostapd dnsmasq
Configure HostAPd:
Edit /etc/hostapd/hostapd.conf:

ini
interface=wlan0
driver=nl80211
ssid=Boat_Central_Hub
hw_mode=g
channel=7
wmm_enabled=0
macaddr_acl=0
auth_algs=1
wpa=2
wpa_passphrase=YourSecurePassword
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
Configure DHCP Server (/etc/dnsmasq.conf):

ini
interface=wlan0
dhcp-range=192.168.50.2,192.168.50.50,255.255.255.0,24h
Set Static IP (/etc/dhcpcd.conf):

ini
interface wlan0
static ip_address=192.168.50.1/24
Enable Services:

bash
sudo systemctl unmask hostapd
sudo systemctl enable hostapd dnsmasq
sudo reboot
Step 2: ESP32-RPi Hardware Connection
text
Raspberry Pi      ESP32
-----------------------------
GPIO 14 (TXD) --> RX0 (GPIO 3)
GPIO 15 (RXD) --> TX0 (GPIO 1)
GND          --> GND
Enable Serial Port on Pi:

Run sudo raspi-config

Navigate to: Interfacing Options > Serial

Disable login shell, enable hardware port

Step 3: Modify ESP32 Code (UART Version)
boatv2.ino:

cpp
#include <HardwareSerial.h>
#include <ESP32Servo.h>

// UART Configuration
HardwareSerial SerialPort(0);  // Use UART0

// Servo pins (same as before)
const int SLIDER_SERVO1_PIN = 18;
const int SLIDER_SERVO2_PIN = 19;
const int JOYSTICK_SERVO_PIN = 21;

// Ultrasonic pins (same as before)
const int NUM_SENSORS = 3;
const int SENSOR_PINS[NUM_SENSORS][2] = {{25,26}, {27,14}, {12,13}};

Servo sliderServo1, sliderServo2, joystickServo;
int sliderAngle = 90, joystickServoAngle = 90;
unsigned long lastSensorSend = 0;

void setup() {
  SerialPort.begin(115200);  // UART communication
  
  // Initialize sensors and servos (same as before)
  for(int i=0; i<NUM_SENSORS; i++) {
    pinMode(SENSOR_PINS[i][0], OUTPUT);
    pinMode(SENSOR_PINS[i][1], INPUT);
  }
  
  sliderServo1.attach(SLIDER_SERVO1_PIN);
  sliderServo2.attach(SLIDER_SERVO2_PIN);
  joystickServo.attach(JOYSTICK_SERVO_PIN);
  
  sliderServo1.write(sliderAngle);
  sliderServo2.write(180 - sliderAngle);
  joystickServo.write(joystickServoAngle);
}

void loop() {
  // Read commands from UART
  if(SerialPort.available()) {
    String command = SerialPort.readStringUntil('\n');
    
    if(command.startsWith("SLIDER_")) {
      int newAngle = command.substring(7).toInt();
      newAngle = constrain(newAngle, 0, 180);
      
      sliderAngle = newAngle;
      sliderServo1.write(sliderAngle);
      sliderServo2.write(180 - sliderAngle);
    }
    else if(command.startsWith("JOY_SERVO_")) {
      int newAngle = command.substring(10).toInt();
      newAngle = constrain(newAngle, 0, 180);
      
      joystickServoAngle = newAngle;
      joystickServo.write(joystickServoAngle);
    }
  }

  // Send sensor data every 300ms
  if(millis() - lastSensorSend >= 300) {
    lastSensorSend = millis();
    
    String data = "SENSORS:";
    for(int i=0; i<NUM_SENSORS; i++) {
      float dist = measureDistance(SENSOR_PINS[i][0], SENSOR_PINS[i][1]);
      data += String(dist,1);
      if(i < NUM_SENSORS-1) data += ",";
    }
    
    SerialPort.println(data); // Send via UART
  }
  delay(10);
}

// measureDistance() remains same as before
Step 4: Raspberry Pi Bridge Service
Create bridge.py:

python
#!/usr/bin/env python3
import socket
import serial
from threading import Thread

# UDP Configuration (for PC communication)
UDP_IP = "0.0.0.0"
UDP_PORT = 12345

# UART Configuration (for ESP32)
SERIAL_PORT = "/dev/serial0"
BAUD_RATE = 115200

class Bridge:
    def __init__(self):
        self.udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.udp_sock.bind((UDP_IP, UDP_PORT))
        self.ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
        self.client_addr = None

    def udp_to_serial(self):
        while True:
            data, addr = self.udp_sock.recvfrom(1024)
            self.client_addr = addr
            self.ser.write(data + b'\n')

    def serial_to_udp(self):
        while True:
            line = self.ser.readline().decode().strip()
            if line and self.client_addr:
                self.udp_sock.sendto(line.encode(), self.client_addr)

    def run(self):
        Thread(target=self.udp_to_serial, daemon=True).start()
        Thread(target=self.serial_to_udp, daemon=True).start()
        while True: 
            pass  # Keep main thread alive

if __name__ == "__main__":
    bridge = Bridge()
    bridge.run()
Make executable:

bash
chmod +x bridge.py
Step 5: Camera Streaming Service
Create camera_stream.py:

python
#!/usr/bin/env python3
import cv2
import socket
import struct
import threading
from picamera2 import Picamera2

# Camera Configuration
picam2 = Picamera2()
picam2.configure(picam2.create_video_configuration(main={"size": (640, 480)}))
picam2.start()

# UDP Streaming Configuration
UDP_IP = "0.0.0.0"
UDP_PORT = 5000

class VideoStreamer:
    def __init__(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind((UDP_IP, UDP_PORT))

    def stream(self):
        while True:
            frame = picam2.capture_array()
            _, jpeg = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 70])
            data = jpeg.tobytes()
            
            # Split into chunks for UDP
            for i in range(0, len(data), 1024):
                chunk = data[i:i+1024]
                self.sock.sendto(struct.pack("I", i) + chunk, self.client_addr)

    def listen(self):
        while True:
            _, self.client_addr = self.sock.recvfrom(1024)

    def run(self):
        Thread(target=self.listen, daemon=True).start()
        self.stream()

if __name__ == "__main__":
    streamer = VideoStreamer()
    streamer.run()
Step 6: Autostart Services on Pi
Create Systemd Service Files:

/etc/systemd/system/bridge.service:

ini
[Unit]
Description=UDP-UART Bridge Service
After=network.target

[Service]
ExecStart=/home/pi/bridge.py
WorkingDirectory=/home/pi
StandardOutput=syslog
StandardError=syslog
Restart=always
User=pi

[Install]
WantedBy=multi-user.target
/etc/systemd/system/camera.service:

ini
[Unit]
Description=Camera Streaming Service
After=network.target

[Service]
ExecStart=/home/pi/camera_stream.py
WorkingDirectory=/home/pi
StandardOutput=syslog
StandardError=syslog
Restart=always
User=pi

[Install]
WantedBy=multi-user.target
Enable Services:

bash
sudo systemctl daemon-reload
sudo systemctl enable bridge.service
sudo systemctl enable camera.service
sudo systemctl start bridge.service
sudo systemctl start camera.service
Step 7: Modify PC Remote Control (remotev5.py)
Key Changes:

Update ESP32_IP to Raspberry Pi's IP (192.168.50.1)

Add video streaming display

python
# Add these imports
import cv2
import threading
import struct

# In RemoteController class __init__:
self.video_ip = "192.168.50.1"
self.video_port = 5000
self.current_frame = None
self.video_running = True

# Add video thread function
def video_thread(self):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('0.0.0.0', 0))
    sock.sendto(b"connect", (self.video_ip, self.video_port))
    
    buffer = {}
    while self.video_running:
        data, _ = sock.recvfrom(65536)
        if len(data) < 4: continue
            
        chunk_id = struct.unpack("I", data[:4])[0]
        buffer[chunk_id] = data[4:]
        
        if len(buffer) * 1024 >= 480*640*3:  # Approx frame size
            frame_data = b''.join([buffer[i] for i in sorted(buffer)])
            self.current_frame = cv2.imdecode(np.frombuffer(frame_data, np.uint8), 1)
            buffer = {}

# In run() method (before main loop):
video_thread = threading.Thread(target=self.video_thread, daemon=True)
video_thread.start()

# In draw_interface() method (add video display):
if self.current_frame is not None:
    frame = cv2.cvtColor(self.current_frame, cv2.COLOR_BGR2RGB)
    frame = pygame.image.frombuffer(frame.tobytes(), frame.shape[1::-1], "RGB")
    self.screen.blit(pygame.transform.scale(frame, (320, 240)), (650, 80))
Final Connection Workflow
Power on Raspberry Pi:

Automatically starts AP, bridge, and camera services

Creates network "Boat_Central_Hub"

Connect PC to Raspberry Pi's WiFi:

SSID: Boat_Central_Hub

Password: YourSecurePassword

Run Remote Control on PC:

bash
python3 remotev5.py
Control Flow:

Control signals: PC → Pi (UDP) → ESP32 (UART)

Sensor data: ESP32 (UART) → Pi (UART) → PC (UDP)

Video: Pi → PC (UDP)

Troubleshooting Tips
Verify services on Pi:

bash
systemctl status bridge.service
systemctl status camera.service
Test UART communication:

bash
minicom -b 115200 -o -D /dev/serial0
Check video stream:

bash
ffplay udp://@:5000
This architecture provides a robust solution that automatically starts all required services on boot, maintains your existing control interface, and adds live video streaming with minimal latency.

Systemd Service Files for Raspberry Pi
1. Bridge Service
/etc/systemd/system/bridge.service

ini
[Unit]
Description=UDP to UART Bridge Service
After=network.target

[Service]
ExecStart=/usr/bin/python3 /home/pi/bridge.py
WorkingDirectory=/home/pi
StandardOutput=syslog
StandardError=syslog
Restart=always
RestartSec=5
User=pi

[Install]
WantedBy=multi-user.target
2. Camera Streaming Service
/etc/systemd/system/camera.service

ini
[Unit]
Description=Camera Streaming Service
After=network.target

[Service]
ExecStart=/usr/bin/python3 /home/pi/camera_stream.py
WorkingDirectory=/home/pi
StandardOutput=syslog
StandardError=syslog
Restart=always
RestartSec=5
User=pi

[Install]
WantedBy=multi-user.target
Setup Instructions
Flash ESP32 with boatv2.ino

Connect ESP32 to Raspberry Pi:

text
ESP32 TX -> Pi GPIO 15 (RXD)
ESP32 RX -> Pi GPIO 14 (TXD)
GND to GND
Copy files to Raspberry Pi:

bridge.py

camera_stream.py

Install required packages on Pi:

bash
sudo apt update
sudo apt install python3-pip python3-picamera2 python3-opencv python3-serial
Enable services:

bash
sudo cp bridge.service /etc/systemd/system/
sudo cp camera.service /etc/systemd/system/
sudo systemctl daemon-reload
sudo systemctl enable bridge.service
sudo systemctl enable camera.service
sudo systemctl start bridge.service
sudo systemctl start camera.service
Run on PC:

bash
python3 remotev5.py
Notes
The system will automatically start on Pi boot

Connect PC to Pi's WiFi network (Boat_Central_Hub)

Camera feed may take 10-15 seconds to initialize

Use 'R' key to reconnect if connection drops

This complete solution provides:

ESP32 control via Raspberry Pi bridge

Live video streaming

Automatic startup on Pi

Enhanced error handling

Smooth UI experience on PC

===================================================================


# Install optimized dependencies
sudo apt update
sudo apt install -y python3-picamera2 python3-libcamera python3-opencv python3-numpy

# Reduce GPU memory allocation
sudo nano /boot/config.txt
# Add/modify: gpu_mem=128

# Increase swap space
sudo nano /etc/dphys-swapfile
# Change: CONF_SWAPSIZE=1024
sudo /etc/init.d/dphys-swapfile restart

# On Pi
sudo apt install htop
htop